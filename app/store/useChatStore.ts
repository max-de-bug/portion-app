import { create } from "zustand";
import { persist } from "zustand/middleware";
import { AIService } from "@/app/config/agent-services";

export interface Message {
  id: string;
  role: "user" | "assistant" | "system";
  content: string;
  timestamp: Date;
  streaming?: boolean;
  status?: "pending" | "processing" | "completed" | "error" | "proposal";
  cost?: number;
  hasAnimated?: boolean;
  proposal?: {
    txBase64: string;
    description: string;
    serviceId: string;
    currency?: string;
  };
}

export interface Conversation {
  id: string;
  title: string;
  messages: Message[];
  selectedService: AIService | null;
  createdAt: Date;
  updatedAt: Date;
}

interface ChatState {
  conversations: Conversation[];
  activeConversationId: string | null;
  input: string;
  
  // Computed-like getters
  getActiveConversation: () => Conversation | undefined;
  getActiveMessages: () => Message[];
  getSelectedService: () => AIService | null;
  
  // Conversation Actions
  createConversation: () => string;
  switchConversation: (id: string) => void;
  deleteConversation: (id: string) => void;
  renameConversation: (id: string, title: string) => void;
  
  // Message Actions (operates on active conversation)
  addMessage: (msg: Message) => void;
  updateMessage: (id: string, updates: Partial<Message>) => void;
  markMessageAsAnimated: (id: string) => void;
  
  // Input Actions
  setInput: (value: string) => void;
  setSelectedService: (service: AIService | null) => void;
  
  // Legacy compatibility
  messages: Message[];
  selectedService: AIService | null;
  clearHistory: () => void;
}

const generateConversationId = () => 
  `conv-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

const generateDefaultTitle = (firstMessage?: string) => {
  if (firstMessage) {
    const trimmed = firstMessage.slice(0, 35);
    return firstMessage.length > 35 ? `${trimmed}...` : trimmed;
  }
  return "New Chat";
};

const createWelcomeMessage = (): Message => ({
  id: "welcome",
  role: "assistant",
  content: "Welcome to **Portion AI** â€” where your intelligence is powered by your capital's growth.\n\n" +
           "Through the **x402 Protocol**, Portion allows you to pay for premium AI services using only the **real-time yield** generated by your sUSDV holdings. This means you can access world-class models like GPT-4 and Claude 3 without ever touching your principal investment.\n\n" +
           "**How to get started:**\n" +
           "1. Select an AI model from the selector above.\n" +
           "2. Ask a question or describe a task.\n" +
           "3. Your sUSDV yield will automatically cover the cost of the interaction.\n\n" +
           "What can I help you build or analyze today?",
  timestamp: new Date(),
  hasAnimated: true,
});

const createDefaultConversation = (): Conversation => ({
  id: generateConversationId(),
  title: "New Chat",
  messages: [createWelcomeMessage()],
  selectedService: null,
  createdAt: new Date(),
  updatedAt: new Date(),
});

export const useChatStore = create<ChatState>()(
  persist(
    (set, get) => ({
      conversations: [createDefaultConversation()],
      activeConversationId: null, // Will be set to first conversation on init
      input: "",
      
      // Computed getters
      getActiveConversation: () => {
        const state = get();
        const id = state.activeConversationId || state.conversations[0]?.id;
        return state.conversations.find(c => c.id === id);
      },
      
      getActiveMessages: () => {
        const conv = get().getActiveConversation();
        return conv?.messages || [];
      },
      
      getSelectedService: () => {
        const conv = get().getActiveConversation();
        return conv?.selectedService || null;
      },
      
      // Legacy computed properties for backwards compatibility
      get messages() {
        return get().getActiveMessages();
      },
      
      get selectedService() {
        return get().getSelectedService();
      },
      
      // Conversation Actions
      createConversation: () => {
        const newConv = createDefaultConversation();
        set(state => ({
          conversations: [newConv, ...state.conversations],
          activeConversationId: newConv.id,
          input: "",
        }));
        return newConv.id;
      },
      
      switchConversation: (id: string) => {
        set({ activeConversationId: id, input: "" });
      },
      
      deleteConversation: (id: string) => {
        set(state => {
          const remaining = state.conversations.filter(c => c.id !== id);
          // If no conversations left, create a new one
          if (remaining.length === 0) {
            const newConv = createDefaultConversation();
            return {
              conversations: [newConv],
              activeConversationId: newConv.id,
            };
          }
          // If active conversation was deleted, switch to first
          const newActiveId = state.activeConversationId === id 
            ? remaining[0].id 
            : state.activeConversationId;
          return {
            conversations: remaining,
            activeConversationId: newActiveId,
          };
        });
      },
      
      renameConversation: (id: string, title: string) => {
        set(state => ({
          conversations: state.conversations.map(c =>
            c.id === id ? { ...c, title, updatedAt: new Date() } : c
          ),
        }));
      },
      
      // Message Actions
      addMessage: (msg: Message) => {
        set(state => {
          const activeId = state.activeConversationId || state.conversations[0]?.id;
          if (!activeId) return state;
          
          return {
            conversations: state.conversations.map(c => {
              if (c.id !== activeId) return c;
              
              // Update title from first user message if still default
              const isFirstUserMessage = msg.role === "user" && 
                c.messages.filter(m => m.role === "user").length === 0;
              const newTitle = isFirstUserMessage && c.title === "New Chat"
                ? generateDefaultTitle(msg.content)
                : c.title;
              
              return {
                ...c,
                title: newTitle,
                messages: [...c.messages, msg],
                updatedAt: new Date(),
              };
            }),
          };
        });
      },
      
      updateMessage: (id: string, updates: Partial<Message>) => {
        set(state => {
          const activeId = state.activeConversationId || state.conversations[0]?.id;
          if (!activeId) return state;
          
          return {
            conversations: state.conversations.map(c => {
              if (c.id !== activeId) return c;
              return {
                ...c,
                messages: c.messages.map(m =>
                  m.id === id ? { ...m, ...updates } : m
                ),
                updatedAt: new Date(),
              };
            }),
          };
        });
      },
      
      markMessageAsAnimated: (id: string) => {
        get().updateMessage(id, { hasAnimated: true });
      },
      
      // Input Actions
      setInput: (value: string) => set({ input: value }),
      
      setSelectedService: (service: AIService | null) => {
        set(state => {
          const activeId = state.activeConversationId || state.conversations[0]?.id;
          if (!activeId) return state;
          
          return {
            conversations: state.conversations.map(c =>
              c.id === activeId ? { ...c, selectedService: service } : c
            ),
          };
        });
      },
      
      // Legacy clear - clears active conversation
      clearHistory: () => {
        set(state => {
          const activeId = state.activeConversationId || state.conversations[0]?.id;
          if (!activeId) return state;
          
          return {
            conversations: state.conversations.map(c =>
              c.id === activeId
                ? {
                    ...c,
                    messages: [createWelcomeMessage()],
                    selectedService: null,
                    title: "New Chat",
                    updatedAt: new Date(),
                  }
                : c
            ),
            input: "",
          };
        });
      },
    }),
    {
      name: "portion_chat_storage_v2",
      partialize: (state) => ({
        conversations: state.conversations,
        activeConversationId: state.activeConversationId,
        input: state.input,
      }),
      // Handle date serialization/deserialization
      storage: {
        getItem: (name: string) => {
          const str = localStorage.getItem(name);
          if (!str) return null;
          
          const parsed = JSON.parse(str);
          // Convert date strings back to Date objects
          if (parsed.state?.conversations) {
            parsed.state.conversations = parsed.state.conversations.map((c: Conversation) => ({
              ...c,
              createdAt: new Date(c.createdAt),
              updatedAt: new Date(c.updatedAt),
              messages: c.messages.map((m: Message) => ({
                ...m,
                timestamp: new Date(m.timestamp),
              })),
            }));
            // Ensure there's always a valid active conversation
            if (!parsed.state.activeConversationId && parsed.state.conversations.length > 0) {
              parsed.state.activeConversationId = parsed.state.conversations[0].id;
            }
          }
          return parsed;
        },
        setItem: (name: string, value: unknown) => {
          localStorage.setItem(name, JSON.stringify(value));
        },
        removeItem: (name: string) => {
          localStorage.removeItem(name);
        },
      },
    }
  )
);
